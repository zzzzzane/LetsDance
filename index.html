<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Custom Card Game</title>
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #f0f4fa; }
    #main { max-width: 1100px; margin: 22px auto 0 auto; }
    .hand-row { display: flex; align-items: center; margin: 12px 0 12px 0; background: rgba(255,255,255,0.94); border-radius: 9px; padding: 5px;}
    .player-label { min-width: 110px; font-weight: 600; font-size: 1.14em; color: #486fb6; text-align: right; margin-right: 8px; }
    .card { display: inline-block; width: 72px; height: 102px; border: 2.5px solid #486fb6; border-radius: 11px; margin: 7px; box-shadow: 0 2px 4px rgba(72, 111, 182, 0.11); background: #fff; cursor: pointer; }
    .card.selected { background: #c7f4fb; border-color: #29b9dd; }
    .card.disabled { opacity: 0.36; pointer-events: none; }
    .card img { width: 100%; height: 100%; object-fit: cover; border-radius: 9px;}
    #play-area { width:100%; background: #fff; border-radius: 12px; margin: 18px 0 0 0; box-shadow: 0 4px 14px rgba(72,111,182,0.10); padding: 20px; }
    #trick-cards, #meld-cards, #discard-pile { display: flex; align-items: center; margin: 6px 0; }
    #meld-area, #discard-pile-area { display: inline-block; font-size: 1.15em; margin-right: 27px;}
    #discard-count { background: #b2bdd6; color: #f7fafc; border-radius: 7px; padding: 2px 11px; margin-left: 10px; font-size: 1.14em; border: 1.6px solid #607bdb;}
    #solo-mode { color: #d90429; font-size: 1.27em; font-weight: bold; margin: 13px 0 13px 0; }
    .picker-instruct { font-size: 1.09em; color: #486fb6; margin-right: 14px;}
    #draft-area { background: #f6f8ff; border: 2px solid #607bdb; border-radius: 11px; margin: 12px auto 16px auto; padding: 22px 12px 17px 12px; width: 80%; min-width: 430px; text-align:center;}
    .draft-cards-row { display: flex; flex-direction: row; gap: 40px; justify-content: center; margin-bottom: 5px;}
    .draft-card-col { display: flex; flex-direction: column; align-items: center; }
    .draft-main-card { width: 110px; height: 156px; margin-bottom: 7px; border-radius: 14px; box-shadow:0 2px 8px rgba(72,111,182,0.10); border: 2.5px solid #607bdb; background: #fff;}
    .draft-btns-row { display: flex; flex-direction: row; gap: 7px; justify-content: center;}
    .draft-pick-btn {
      font-size: 1em; background: linear-gradient(90deg,#486fb6,#607bdb); color: #fff; border: none; 
      border-radius: 6px; font-weight: 600; padding: 6px 11px; box-shadow:0 1px 6px rgba(72,111,182,0.08); cursor:pointer; margin-top: 1px;
    }
    .draft-pick-btn:disabled { background: #bccbe8; color: #dde1f3;}
    #game-log-area { background: #f6f8ff; border: 2px solid #dddff2; border-radius: 10px; margin: 22px 0 0 0; min-height:70px; max-height:190px; overflow-y:auto; padding: 10px 22px;}
    #game-log-area h3 { margin: 3px 0 10px 0; color:#2955a7; font-size:1.09em;}
    .log-entry { margin-bottom: 5px;}
    .log-card { display:inline-block; width: 44px; height: 63px; vertical-align:middle; margin-left: 6px;}
    .log-card img { width:100%; height:100%; border-radius:6px; border:1px solid #ccc;}
    .log-player { color:#243685; font-weight:600;}
    #turn-indicator { margin: 16px 0 11px 0; font-weight: bold; font-size: 1.20em; color: #243685; text-align:center;}
  </style>
</head>
<body>
  <div id="main">
    <div id="hands"></div>
    <div id="turn-indicator"></div>
    <div id="play-area">
      <div id="draft-area" style="display:none;"></div>
      <div id="trick-cards"></div>
      <div id="action-buttons"></div>
      <div id="solo-mode"></div>
      <div id="special-picker"></div>
      <div style="margin:15px 0 4px 0;">
        <span id="meld-area"><b>Winning Meld:</b> <span id="meld-cards"></span></span>
        <span id="discard-pile-area"><b>Discard Pile:</b> <span id="discard-count">0</span></span>
      </div>
      <button onclick="startGame()">Start New Game</button>
    </div>
    <div id="game-log-area">
      <h3>Game Log</h3>
      <div id="game-log"></div>
    </div>
  </div>
  <script>
    const NUM_PLAYERS = 4, CARDS_PER_PLAYER = 13, CARD_VALUES = [1,2,3,4,5,6,7,8,9], COPIES_PER_CARD = 6;
    let hands = [], deck = [], selectedCards = [], currentPlayer = 0, turnPhase = "LEAD", trickLead = 0,
        trick = [], meld = [], discardCount = 0, soloMode = false, specialPickerState = null;
    let gameLog = [];
    let draftPhase = false, draftCards = [], draftStep = 0;

    /********* LOGGING & RENDER ***********/
    function logAction(msg, player, cards) {
      let html = '';
      if(player!==undefined) html += `<span class="log-player">Player ${player+1}</span>: `;
      html += msg;
      if(cards && cards.length > 0) {
        for(let c of cards) {
          html += `<span class="log-card"><img src="./images/card_${c.value}.jpg" alt="${c.value}"></span>`;
        }
      }
      gameLog.push(html);
      renderGameLog();
    }
    function renderGameLog() {
      const area = document.getElementById('game-log');
      area.innerHTML = gameLog.slice(-20).map(l=>`<div class="log-entry">${l}</div>`).join('');
      area.scrollTop = area.scrollHeight;
    }

    /********* DECK/DEAL ***********/
    function buildDeck() {
      let d = [];
      for(let v of CARD_VALUES) for(let c=0; c<COPIES_PER_CARD; c++) d.push({value: v});
      for(let i=d.length-1; i>0; i--) { let j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]];}
      return d;
    }
    function dealHands() {
      deck = buildDeck();
      hands = [];
      for(let p=0; p<NUM_PLAYERS; p++) {
        hands.push([]);
        for(let i=0; i<CARDS_PER_PLAYER; i++) hands[p].push(deck.pop());
        hands[p].sort((a,b)=>a.value-b.value);
      }
    }

    /********* UI DISPLAY ***********/
    function displayHands() {
      const handsCtn = document.getElementById("hands");
      handsCtn.innerHTML = "";
      for(let p=0; p<NUM_PLAYERS; p++) {
        const row = document.createElement('div');
        row.className = "hand-row";
        const label = document.createElement('span');
        label.className = "player-label";
        label.textContent = (p === currentPlayer) ? "You:" : `Player ${p + 1}:`;
        row.appendChild(label);
        hands[p].forEach((card, idx) => {
          const cardDiv = document.createElement('div');
          cardDiv.className = "card";
          const img = document.createElement('img');
          img.src = `./images/card_${card.value}.jpg`;
          img.alt = card.value;
          cardDiv.appendChild(img);
          if(p===currentPlayer && (turnPhase==="LEAD" || turnPhase==="PARTNER")){
            cardDiv.onclick = () => toggleCard(idx);
            if(selectedCards.includes(idx)) cardDiv.classList.add("selected");
          } else {
            cardDiv.classList.add("disabled");
          }
          row.appendChild(cardDiv);
        });
        handsCtn.appendChild(row);
      }
    }

    function displayTrick(pickableIndexes=null,pickHandler=null,label=null) {
      const area = document.getElementById('trick-cards');
      area.innerHTML = (label? `<span class="picker-instruct">${label}</span>` : "<b>Current Trick:</b>&nbsp;");
      if(pickableIndexes && pickableIndexes.length>0) {
        trick.forEach((card,i)=>{
          if(!pickableIndexes.includes(i)) return;
          const div = document.createElement('div');
          div.className='card';
          const img=document.createElement('img');
          img.src=`./images/card_${card.value}.jpg`; img.alt=card.value;
          div.appendChild(img);
          div.onclick=()=>pickHandler(i);
          area.appendChild(div);
        });
      } else {
        selectedCards.forEach(idx=>{
          const card=hands[currentPlayer][idx];
          const div=document.createElement('div');
          div.className='card selected';
          const img=document.createElement('img');
          img.src=`./images/card_${card.value}.jpg`;
          img.alt=card.value; div.appendChild(img);
          div.title='Click to remove';
          div.onclick=()=>{selectedCards=selectedCards.filter(i=>i!==idx);displayHands();updateActionButtons();displayTrick();}
          area.appendChild(div);
        });
        trick.forEach(card=>{
          const div=document.createElement('div');
          div.className='card';
          const img=document.createElement('img');
          img.src=`./images/card_${card.value}.jpg`;
          img.alt=card.value;
          div.appendChild(img);
          area.appendChild(div);
        });
      }
    }
    function displayWinningMeld() {
      const area = document.getElementById('meld-cards'); area.innerHTML = "";
      meld.forEach(card => {
        const div = document.createElement('div');
        div.className = 'card';
        const img = document.createElement('img');
        img.src = `./images/card_${card.value}.jpg`; img.alt = card.value;
        div.appendChild(img); area.appendChild(div);
      });
    }
    function displayDiscardCount() { document.getElementById('discard-count').textContent = discardCount;}

    function updateActionButtons() {
      const ab = document.getElementById('action-buttons'); ab.innerHTML = "";
      document.getElementById('solo-mode').innerHTML = "";
      document.getElementById('special-picker').innerHTML = "";
      if(draftPhase) return;
      if(turnPhase==="LEAD" && meld.length>0){
        const passBtn = document.createElement('button');
        passBtn.textContent = "Pass";
        passBtn.onclick = leadPass;
        ab.appendChild(passBtn);
      }
      if(turnPhase==="LEAD"){
        const btn = document.createElement('button');
        btn.textContent = "Submit Trick (Lead)";
        btn.disabled = selectedCards.length < 1;
        btn.onclick = submitLead;
        ab.appendChild(btn);
      }
      if(turnPhase==="PARTNER"){
        const passBtn = document.createElement('button');
        passBtn.textContent = "Pass";
        passBtn.disabled = !partnerCanPass();
        passBtn.onclick = partnerPass; ab.appendChild(passBtn);
        const submitBtn = document.createElement('button');
        submitBtn.textContent = "Submit as Partner";
        submitBtn.disabled = (selectedCards.length===0 || !validateFollowPlay(selectedCards,currentPlayer,hands[currentPlayer],trick,{}));
        submitBtn.onclick = submitPartner; ab.appendChild(submitBtn);
      }
    }

    function updateTurnIndicator(msgOverride) {
      const t = document.getElementById('turn-indicator');
      if(msgOverride) { t.textContent = msgOverride; return; }
      let who = (turnPhase==="LEAD") ? `Your turn as: Lead (Player ${currentPlayer+1}) (select 1–3 cards, Submit)` :
        (turnPhase==="PARTNER" ? `Your turn as: Partner (Player ${currentPlayer+1}) (complete the meld if possible—select 0–3 cards, Submit/Pass)` :
         turnPhase==="SELECT_LEAD_PICK" ? `Lead: Player ${trickLead+1} pick a card to take back` :
         turnPhase==="SELECT_PARTNER_PICK" ? `Partner: Player ${currentPlayer+1} pick a card to take back` : "");
      t.textContent = who ? who : "";
    }

    /********* DRAFT LOGIC ***********/
    function showDraftStep() {
      draftPhase = true;
      updateTurnIndicator();
      updateActionButtons();
      displayHands();
      let area = document.getElementById("draft-area");
      area.style.display = "block";
      area.innerHTML = "";
      if (draftStep === 0) {
        let row = document.createElement('div');
        row.className = "draft-cards-row";
        draftCards.forEach((card, ci) => {
          let col = document.createElement('div');
          col.className = 'draft-card-col';
          let img = document.createElement('img');
          img.className = "draft-main-card";
          img.src = `./images/card_${card.value}.jpg`;
          img.alt = card.value;
          col.appendChild(img);
          let btns = document.createElement('div');
          btns.className = "draft-btns-row";
          [1,3].forEach(playerIdx => {
            const btn = document.createElement('button');
            btn.className = "draft-pick-btn";
            btn.innerText = `Player ${playerIdx+1}`;
            btn.onclick = ()=>draftAssignCard(ci,playerIdx);
            btns.appendChild(btn);
          });
          col.appendChild(btns);
          row.appendChild(col);
        });
        area.appendChild(row);
      } else if (draftStep === 1) {
        let card = draftCards[0];
        let row = document.createElement('div');
        row.className = "draft-cards-row";
        let col = document.createElement('div');
        col.className = 'draft-card-col';
        let img = document.createElement('img');
        img.className = "draft-main-card";
        img.src = `./images/card_${card.value}.jpg`;
        img.alt = card.value;
        col.appendChild(img);
        let btns = document.createElement('div');
        btns.className = "draft-btns-row";
        [0,2].forEach(playerIdx => {
          const btn = document.createElement('button');
          btn.className = "draft-pick-btn";
          btn.innerText = `Player ${playerIdx+1}`;
          btn.onclick = ()=>draftAssignCard(0,playerIdx);
          btns.appendChild(btn);
        });
        col.appendChild(btns);
        row.appendChild(col);
        area.appendChild(row);
      } else {
        area.style.display = "none";
        draftPhase = false;
        updateTurnIndicator();
        updateActionButtons();
        displayHands();
      }
    }
    function draftAssignCard(ci, playerIdx) {
      const card = draftCards[ci];
      hands[playerIdx].push(card);
      hands[playerIdx].sort((a,b)=>a.value-b.value);
      logAction("drafted extra card", playerIdx, [card]);
      draftCards.splice(ci,1);
      if(draftStep === 0) {
        draftStep = 1;
        showDraftStep();
      } else {
        draftStep = 2;
        showDraftStep();
      }
    }

    /********* MELD AND VALIDATION LOGIC ***********/
    function getMeldTypeInfo(cards) {
      if (!cards || cards.length < 2) return null;
      cards = cards.slice().sort((a, b) => a.value - b.value);

      // Bomb (4 of a kind)
      if (cards.length === 4 && cards.every(c => c.value === cards[0].value))
        return { type: "bomb", length: 4, value: cards[0].value };

      // Stairs (two consecutive pairs)
      if (cards.length === 4) {
        let a = cards[0].value, b = cards[2].value;
        if (
          cards[0].value === cards[1].value &&
          cards[2].value === cards[3].value &&
          b === a + 1
        )
          return { type: "stairs", length: 4, value: a };
      }
      // Trips
      if (cards.length === 3 && cards.every(c => c.value === cards[0].value))
        return { type: "trips", length: 3, value: cards[0].value };
      // Pair
      if (cards.length === 2 && cards[0].value === cards[1].value)
        return { type: "pair", length: 2, value: cards[0].value };
      // Run (2–4 in sequence, unique)
      if (cards.length >= 2 && cards.length <= 4) {
        let allConsecutive = true, seen = new Set([cards[0].value]);
        for (let i = 1; i < cards.length; ++i) {
          if (cards[i].value !== cards[i-1].value + 1 || seen.has(cards[i].value)) {
            allConsecutive = false; break;
          }
          seen.add(cards[i].value);
        }
        if (allConsecutive)
          return { type: "run", length: cards.length, value: cards[cards.length-1].value };
      }
      return null;
    }
    function canBeatWinningMeld(candidate, currentMeld) {
      let candType = getMeldTypeInfo(candidate);
      let winType = getMeldTypeInfo(currentMeld);

      if (!candType || !winType) return false;

      // Bomb can always beat any non-bomb
      if (candType.type === "bomb" && winType.type !== "bomb") return true;

      // Bomb over bomb – ONLY higher value allowed
      if (winType.type === "bomb") {
        return candType.type === "bomb" && candType.value > winType.value;
      }

      // Otherwise must be same type and length, and strictly higher value
      if (candType.type !== winType.type) return false;
      if (candType.length !== winType.length) return false;

      return candType.value > winType.value;
    }

    function canPartnerCompleteMeld(partnerHand, leadCards, currentWinningMeld) {
      // Try all possible subsets of partner's hand (size 1-3) to build a valid meld with lead's cards
      for (let size = 1; size <= Math.min(3, partnerHand.length); size++) {
        let indices = Array.from({length: partnerHand.length}, (_, i) => i);
        let combos = getAllCombinations(indices, size);
        for (let combo of combos) {
          let selected = combo.map(idx => partnerHand[idx]);
          let trick = leadCards.concat(selected);
          let candidate = getMeldTypeInfo(trick);
          if (!candidate) continue;
          if (!currentWinningMeld || canBeatWinningMeld(trick, currentWinningMeld)) {
            return true;
          }
        }
      }
      return false;
    }

    function getAllCombinations(arr, k) {
      let results = [];
      function combo(temp, start) {
        if (temp.length === k) {
          results.push([...temp]);
          return;
        }
        for (let i = start; i < arr.length; i++) {
          temp.push(arr[i]);
          combo(temp, i + 1);
          temp.pop();
        }
      }
      combo([], 0);
      return results;
    }

    function partnerCanPass() {
      // Partner can pass only if there is *no possible combination* (adding 1–3 cards) that would complete a valid meld (and beat winning meld if applicable)
      return !canPartnerCompleteMeld(hands[currentPlayer], trick, (meld.length > 0 ? meld : null));
    }

    function validateLeadPlay(selectedCards, playerNum, hand, gameState) {
      // Lead must play 1–3 cards
      return selectedCards.length >= 1 && selectedCards.length <= 3;
      // (You can further restrict here if you want only "partial" possible meld bases. For now we allow any 1–3 cards; it's only after partner contribution the valid meld enforcement kicks in.)
    }
    function validateFollowPlay(selectedCards, playerNum, hand, leadCards, gameState) {
      let trick = leadCards.concat(selectedCards);

      // If partner is passing:
      if (selectedCards.length === 0) {
        // Allow pass only if cannot complete meld per rules
        return partnerCanPass();
      }
      // Must form valid meld with combined trick
      let candidate = getMeldTypeInfo(trick);
      if (!candidate) return false;
      if (meld.length === 0) {
        return true;
      } else {
        // Must beat meld if established
        return canBeatWinningMeld(trick, meld);
      }
    }
    function validateMeld(trickCards, gameState) {
      return getMeldTypeInfo(trickCards) !== null;
    }

    /********* GAMEPLAY LOGIC ***********/
    function toggleCard(idx) {
      if(turnPhase === "LEAD") {
        if(selectedCards.includes(idx)) selectedCards = selectedCards.filter(i=>i!==idx);
        else if(selectedCards.length < 3) selectedCards.push(idx);
      }
      if(turnPhase === "PARTNER") {
        if(selectedCards.includes(idx)) selectedCards = selectedCards.filter(i=>i!==idx);
        else if(selectedCards.length < 3) selectedCards.push(idx);
      }
      displayHands(); updateActionButtons();
    }

    function submitLead() {
      const toPlay = selectedCards.map(i => hands[currentPlayer][i]);
      if(!validateLeadPlay(toPlay,currentPlayer,hands[currentPlayer],{})){alert("Lead play invalid!");return;}
      logAction(`played`, currentPlayer, toPlay);
      selectedCards.sort((a,b)=>b-a).forEach(i=>hands[currentPlayer].splice(i,1));
      trick = [...toPlay]; selectedCards = [];
      displayHands(); displayTrick(); updateActionButtons();
      let partner=(currentPlayer%2===0)?(currentPlayer===0?2:0):(currentPlayer===1?3:1);
      logAction(`passes to Partner (Player ${partner+1})`, currentPlayer);
      currentPlayer=partner; turnPhase="PARTNER";
      updateTurnIndicator(); displayHands(); displayTrick(); updateActionButtons();
    }

    function partnerPass() {
      logAction(`passed`, currentPlayer);
      // Trick remains as-is; since no meld, previous meld wins
      processEndOfTrick();
    }

    function submitPartner() {
      const toPlay = selectedCards.map(i=>hands[currentPlayer][i]);
      if(!validateFollowPlay(toPlay,currentPlayer,hands[currentPlayer],trick,{})){alert("Partner play invalid or must play if able!");return;}
      logAction("added", currentPlayer, toPlay);
      selectedCards.sort((a,b)=>b-a).forEach(i=>hands[currentPlayer].splice(i,1));
      trick = [...trick, ...toPlay]; selectedCards = [];
      displayHands(); displayTrick(); updateActionButtons();
      processEndOfTrick();
    }

    function processEndOfTrick() {
      // If no partner action, trick left as is
      let completed = trick.length > 0 ? getMeldTypeInfo(trick) : null;
      if (completed && (meld.length === 0 || canBeatWinningMeld(trick, meld))) {
        logAction("meld/played cards become new winning meld", undefined, trick);
        discardCount += meld.length; displayDiscardCount(); meld = [...trick];
      } else {
        logAction("meld/played cards discarded", undefined, trick);
        discardCount += trick.length; displayDiscardCount();
      }
      trick = [];
      trickLead = (trickLead + 1) % NUM_PLAYERS;
      currentPlayer = trickLead;
      turnPhase = "LEAD"; selectedCards = [];
      updateTurnIndicator(); displayHands(); displayTrick(); updateActionButtons(); displayWinningMeld();
    }

    /********* GAME START/RESET ***********/
    function startGame() {
      gameLog = [];
      dealHands();
      draftPhase = true;
      draftCards = [deck.pop(), deck.pop()];
      draftStep = 0;

      currentPlayer=0; trick=[]; trickLead=0; turnPhase="LEAD"; selectedCards=[]; meld=[]; discardCount=0; soloMode = false; specialPickerState = null;
      updateTurnIndicator(); displayHands(); displayTrick(); updateActionButtons(); displayWinningMeld(); displayDiscardCount();
      document.getElementById('solo-mode').innerHTML = "";
      document.getElementById('special-picker').innerHTML = "";
      showDraftStep();
      renderGameLog();
      logAction("Game started and cards dealt--v3");
      logAction("Draft phase: two cards to be assigned before game");
    }
    window.onload = startGame;
  </script>
</body>
</html>

